name: Update Download Metrics

on:
  # ruleaza AUTOMAT dupa workflow-ul de build/upload ZIP
  workflow_run:
    workflows: ["Build & Upload HACS ZIP"]
    types: [completed]

  # ruleaza si la publicarea release-ului (fallback)
  release:
    types: [published]

  # ruleaza zilnic (an caz ca apar descarcări noi)
  schedule:
    - cron: "20 0 * * *"

  # rulează manual
  workflow_dispatch:

permissions:
  contents: write
  actions: read

jobs:
  metrics:
    if: github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: Generate metrics (totals, latest, top5)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const repo = context.repo;

            // --- 1) Aduna toate release-urile (100 per pagina, paginate) ---
            let releases = await github.paginate(
              github.rest.repos.listReleases,
              { owner: repo.owner, repo: repo.repo, per_page: 100 }
            );

            // ignor drafts (pastreaza prerelease dacă vrei)
            releases = releases.filter(r => !r.draft);

            // --- 2) Calculeaza totaluri & pe release ---
            let totalAll = 0;
            const perRelease = [];
            const perAsset = [];

            for (const r of releases) {
              const assets = r.assets || [];
              const relTotal = assets.reduce((acc, a) => acc + (a.download_count || 0), 0);
              totalAll += relTotal;

              perRelease.push({
                tag: r.tag_name,
                name: r.name,
                prerelease: r.prerelease,
                published_at: r.published_at,
                downloads: relTotal,
                assets: assets.map(a => ({
                  name: a.name,
                  download_count: a.download_count || 0,
                  browser_download_url: a.browser_download_url
                }))
              });

              for (const a of assets) {
                perAsset.push({
                  tag: r.tag_name,
                  name: a.name,
                  download_count: a.download_count || 0,
                  browser_download_url: a.browser_download_url
                });
              }
            }

            // sortare: Top 5 versiuni după downloads
            const top5 = [...perRelease].sort((a,b) => b.downloads - a.downloads).slice(0,5);

            // latest release (dupa data publicare) – releases e deja desc, dar securizam
            const latest = [...perRelease].sort(
              (a,b) => new Date(b.published_at) - new Date(a.published_at)
            )[0] || null;

            // --- 3) Scrie fisierele în /metrics ---
            const now = new Date().toISOString();
            const metricsDir = path.join(process.cwd(), 'metrics');
            const shieldsDir = path.join(metricsDir, 'shields');
            if (!fs.existsSync(metricsDir)) fs.mkdirSync(metricsDir, { recursive: true });
            if (!fs.existsSync(shieldsDir)) fs.mkdirSync(shieldsDir, { recursive: true });

            // 3a) Snapshot curent
            fs.writeFileSync(
              path.join(metricsDir, 'downloads.json'),
              JSON.stringify({
                generated_at: now,
                repository: `${repo.owner}/${repo.repo}`,
                total_downloads: totalAll,
                per_release: perRelease,
                per_asset: perAsset
              }, null, 2)
            );

            // 3b) Istoric (append JSONL)
            fs.appendFileSync(
              path.join(metricsDir, 'downloads.history.jsonl'),
              JSON.stringify({ timestamp: now, total_downloads: totalAll, per_release: perRelease }) + '\n'
            );

            // 3c) Top 5 versiuni (JSON)
            fs.writeFileSync(
              path.join(metricsDir, 'top_versions.json'),
              JSON.stringify({ generated_at: now, top: top5 }, null, 2)
            );

            // 3d) Top 5 versiuni (Markdown pentru vizualizare rapida în repo)
            const rows = top5.map((r, i) =>
              `| ${i+1} | ${r.tag} | ${r.downloads} | ${r.published_at ? r.published_at.split('T')[0] : ''} |`
            ).join('\n');
            const md = `# Top 5 Versiuni dupa Downloads\n\nUltima generare: ${now}\n\n` +
              `| # | Versiune | Downloads | Publicat |\n| - | - | -: | - |\n${rows}\n`;
            fs.writeFileSync(path.join(metricsDir, 'TOP.md'), md);

            // 3e) Shields: total downloads (toate release assets)
            const totalPretty = new Intl.NumberFormat('en-US').format(totalAll);
            fs.writeFileSync(
              path.join(shieldsDir, 'downloads.json'),
              JSON.stringify({
                schemaVersion: 1,
                label: "downloads (assets)",
                message: totalPretty,
                color: "blue"
              })
            );

            // 3f) Shields: latest release downloads
            const latestCount = latest ? latest.downloads : 0;
            fs.writeFileSync(
              path.join(shieldsDir, 'latest_release.json'),
              JSON.stringify({
                schemaVersion: 1,
                label: "latest release downloads",
                message: String(latestCount),
                color: "informational"
              })
            );

      - name: Commit metrics
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(metrics): refresh totals, latest & top5"
          file_pattern: |
            metrics/downloads.json
            metrics/downloads.history.jsonl
            metrics/top_versions.json
            metrics/TOP.md
            metrics/shields/downloads.json
            metrics/shields/latest_release.json
